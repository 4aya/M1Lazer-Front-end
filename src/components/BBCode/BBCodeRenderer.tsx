import React, { useEffect, useRef } from 'react';
import '../../styles/bbcode.css';

interface BBCodeRendererProps {
  html: string;
  className?: string;
}

/**
 * BBCode HTML Rendering components
 * Render safelyBBCodeGenerated by parserHTMLand add interactive features
 */
const BBCodeRenderer: React.FC<BBCodeRendererProps> = ({ html, className = '' }) => {
  const containerRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    if (!containerRef.current) return;

    const container = containerRef.current;

    // Initialize the folding box function
    const initializeSpoilerBoxes = () => {
      const spoilerLinks = container.querySelectorAll('.js-spoilerbox__link');
      const cleanupFunctions: (() => void)[] = [];
      
      spoilerLinks.forEach((button) => {
        // Remove the old event listener that may exist first
        const existingHandler = (button as any).__spoilerClickHandler;
        if (existingHandler) {
          button.removeEventListener('click', existingHandler);
        }
        
        const handleClick = (e: Event) => {
          e.preventDefault();
          e.stopPropagation();
          
          const spoilerBox = button.closest('.js-spoilerbox');
          const body = spoilerBox?.querySelector('.js-spoilerbox__body');
          
          if (body) {
            const isVisible = body.classList.contains('is-visible');
            body.classList.toggle('is-visible', !isVisible);
            button.setAttribute('aria-expanded', String(!isVisible));
            
            // Trigger custom events
            spoilerBox?.dispatchEvent(new CustomEvent('spoilerToggle', {
              detail: { expanded: !isVisible }
            }));
          }
        };

        // Store event processor references for cleaning
        (button as any).__spoilerClickHandler = handleClick;
        button.addEventListener('click', handleClick);
        
        // Set initial state - buttonThe element has the correct attributes by default
        button.setAttribute('aria-expanded', 'false');
        
        // Add a cleanup function
        cleanupFunctions.push(() => {
          button.removeEventListener('click', handleClick);
          delete (button as any).__spoilerClickHandler;
        });
      });
      
      // Returns the total cleaning function
      return () => {
        cleanupFunctions.forEach(cleanup => cleanup());
      };
    };

    // Initialize spoiler bar function
    const initializeSpoilers = () => {
      const spoilers = container.querySelectorAll('.spoiler');
      const cleanupFunctions: (() => void)[] = [];
      
      spoilers.forEach((spoiler) => {
        const handleReveal = () => {
          spoiler.classList.add('revealed');
        };

        const handleKeydown = (e: Event) => {
          const keyEvent = e as KeyboardEvent;
          if (keyEvent.key === 'Enter' || keyEvent.key === ' ') {
            e.preventDefault();
            handleReveal();
          }
        };

        // Click to display
        spoiler.addEventListener('click', handleReveal);
        
        // Mouse hover display
        spoiler.addEventListener('mouseenter', handleReveal);
        
        // Support keyboard operation
        spoiler.setAttribute('tabindex', '0');
        spoiler.setAttribute('role', 'button');
        spoiler.setAttribute('aria-label', 'Click to displayHide content');
        
        spoiler.addEventListener('keydown', handleKeydown);
        
        // Add a cleanup function
        cleanupFunctions.push(() => {
          spoiler.removeEventListener('click', handleReveal);
          spoiler.removeEventListener('mouseenter', handleReveal);
          spoiler.removeEventListener('keydown', handleKeydown);
        });
      });
      
      // Returns the total cleaning function
      return () => {
        cleanupFunctions.forEach(cleanup => cleanup());
      };
    };

    // Initialize image mapping function
    const initializeImageMaps = () => {
      const imageMaps = container.querySelectorAll('.imagemap');
      const cleanupFunctions: (() => void)[] = [];
      
      imageMaps.forEach((imageMap) => {
        const links = imageMap.querySelectorAll('.imagemap__link');
        
        links.forEach((link) => {
          const handleMouseEnter = () => {
            link.classList.add('hover');
          };
          
          const handleMouseLeave = () => {
            link.classList.remove('hover');
          };
          
          const handleClick = (e: Event) => {
            e.preventDefault();
          };
          
          // Add hover effect
          link.addEventListener('mouseenter', handleMouseEnter);
          link.addEventListener('mouseleave', handleMouseLeave);
          
          // If it is an information area (nohref), add a prompt
          if (!link.getAttribute('href') || link.getAttribute('href') === '#') {
            link.addEventListener('click', handleClick);
          }
          
          // Add a cleanup function
          cleanupFunctions.push(() => {
            link.removeEventListener('mouseenter', handleMouseEnter);
            link.removeEventListener('mouseleave', handleMouseLeave);
            if (!link.getAttribute('href') || link.getAttribute('href') === '#') {
              link.removeEventListener('click', handleClick);
            }
          });
        });
      });
      
      // Returns the total cleaning function
      return () => {
        cleanupFunctions.forEach(cleanup => cleanup());
      };
    };

    // Initialize all interactive functions and collect cleaning functions
    const cleanupSpoilerBoxes = initializeSpoilerBoxes();
    const cleanupSpoilers = initializeSpoilers();
    const cleanupImageMaps = initializeImageMaps();
    
    // Returns the total cleaning function
    return () => {
      cleanupSpoilerBoxes?.();
      cleanupSpoilers?.();
      cleanupImageMaps?.();
    };

    // Process external links
    const externalLinks = container.querySelectorAll('a[href^="http"]');
    externalLinks.forEach((link) => {
      link.setAttribute('target', '_blank');
      link.setAttribute('rel', 'noopener noreferrer');
    });

    // Lazy image loading
    const images = container.querySelectorAll('img[loading="lazy"]');
    if ('IntersectionObserver' in window) {
      const imageObserver = new IntersectionObserver((entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            const img = entry.target as HTMLImageElement;
            if (img.dataset.src) {
              img.src = img.dataset.src;
              img.removeAttribute('data-src');
              imageObserver.unobserve(img);
            }
          }
        });
      });

      images.forEach((img) => imageObserver.observe(img));

      return () => {
        imageObserver.disconnect();
      };
    }
  }, [html]);

  return (
    <div
      ref={containerRef}
      className={`bbcode-renderer ${className}`}
      dangerouslySetInnerHTML={{ __html: html }}
      aria-live="polite"
    />
  );
};

export default BBCodeRenderer;